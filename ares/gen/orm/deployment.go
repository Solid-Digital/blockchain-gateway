// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package orm

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/unchainio/pkg/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Deployment is an object representing the database table.
type Deployment struct {
	ID              int64     `boil:"id" json:"id" toml:"id" yaml:"id"`
	PipelineID      int64     `boil:"pipeline_id" json:"pipelineID" toml:"pipelineID" yaml:"pipelineID"`
	ConfigurationID int64     `boil:"configuration_id" json:"configurationID" toml:"configurationID" yaml:"configurationID"`
	EnvironmentID   int64     `boil:"environment_id" json:"environmentID" toml:"environmentID" yaml:"environmentID"`
	CreatedAt       time.Time `boil:"created_at" json:"createdAt" toml:"createdAt" yaml:"createdAt"`
	CreatedByID     int64     `boil:"created_by_id" json:"createdByID" toml:"createdByID" yaml:"createdByID"`
	UpdatedAt       time.Time `boil:"updated_at" json:"updatedAt" toml:"updatedAt" yaml:"updatedAt"`
	UpdatedByID     int64     `boil:"updated_by_id" json:"updatedByID" toml:"updatedByID" yaml:"updatedByID"`
	Replicas        int64     `boil:"replicas" json:"replicas" toml:"replicas" yaml:"replicas"`
	URL             string    `boil:"url" json:"url" toml:"url" yaml:"url"`
	Image           string    `boil:"image" json:"image" toml:"image" yaml:"image"`
	Host            string    `boil:"host" json:"host" toml:"host" yaml:"host"`
	Path            string    `boil:"path" json:"path" toml:"path" yaml:"path"`
	RewriteTarget   string    `boil:"rewrite_target" json:"rewriteTarget" toml:"rewriteTarget" yaml:"rewriteTarget"`
	FullName        string    `boil:"full_name" json:"fullName" toml:"fullName" yaml:"fullName"`
	Dirty           bool      `boil:"dirty" json:"dirty" toml:"dirty" yaml:"dirty"`

	R *deploymentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L deploymentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DeploymentColumns = struct {
	ID              string
	PipelineID      string
	ConfigurationID string
	EnvironmentID   string
	CreatedAt       string
	CreatedByID     string
	UpdatedAt       string
	UpdatedByID     string
	Replicas        string
	URL             string
	Image           string
	Host            string
	Path            string
	RewriteTarget   string
	FullName        string
	Dirty           string
}{
	ID:              "id",
	PipelineID:      "pipeline_id",
	ConfigurationID: "configuration_id",
	EnvironmentID:   "environment_id",
	CreatedAt:       "created_at",
	CreatedByID:     "created_by_id",
	UpdatedAt:       "updated_at",
	UpdatedByID:     "updated_by_id",
	Replicas:        "replicas",
	URL:             "url",
	Image:           "image",
	Host:            "host",
	Path:            "path",
	RewriteTarget:   "rewrite_target",
	FullName:        "full_name",
	Dirty:           "dirty",
}

// Generated where

var DeploymentWhere = struct {
	ID              whereHelperint64
	PipelineID      whereHelperint64
	ConfigurationID whereHelperint64
	EnvironmentID   whereHelperint64
	CreatedAt       whereHelpertime_Time
	CreatedByID     whereHelperint64
	UpdatedAt       whereHelpertime_Time
	UpdatedByID     whereHelperint64
	Replicas        whereHelperint64
	URL             whereHelperstring
	Image           whereHelperstring
	Host            whereHelperstring
	Path            whereHelperstring
	RewriteTarget   whereHelperstring
	FullName        whereHelperstring
	Dirty           whereHelperbool
}{
	ID:              whereHelperint64{field: "\"deployment\".\"id\""},
	PipelineID:      whereHelperint64{field: "\"deployment\".\"pipeline_id\""},
	ConfigurationID: whereHelperint64{field: "\"deployment\".\"configuration_id\""},
	EnvironmentID:   whereHelperint64{field: "\"deployment\".\"environment_id\""},
	CreatedAt:       whereHelpertime_Time{field: "\"deployment\".\"created_at\""},
	CreatedByID:     whereHelperint64{field: "\"deployment\".\"created_by_id\""},
	UpdatedAt:       whereHelpertime_Time{field: "\"deployment\".\"updated_at\""},
	UpdatedByID:     whereHelperint64{field: "\"deployment\".\"updated_by_id\""},
	Replicas:        whereHelperint64{field: "\"deployment\".\"replicas\""},
	URL:             whereHelperstring{field: "\"deployment\".\"url\""},
	Image:           whereHelperstring{field: "\"deployment\".\"image\""},
	Host:            whereHelperstring{field: "\"deployment\".\"host\""},
	Path:            whereHelperstring{field: "\"deployment\".\"path\""},
	RewriteTarget:   whereHelperstring{field: "\"deployment\".\"rewrite_target\""},
	FullName:        whereHelperstring{field: "\"deployment\".\"full_name\""},
	Dirty:           whereHelperbool{field: "\"deployment\".\"dirty\""},
}

// DeploymentRels is where relationship names are stored.
var DeploymentRels = struct {
	Configuration string
	CreatedBy     string
	Environment   string
	Pipeline      string
	UpdatedBy     string
}{
	Configuration: "Configuration",
	CreatedBy:     "CreatedBy",
	Environment:   "Environment",
	Pipeline:      "Pipeline",
	UpdatedBy:     "UpdatedBy",
}

// deploymentR is where relationships are stored.
type deploymentR struct {
	Configuration *Configuration
	CreatedBy     *User
	Environment   *Environment
	Pipeline      *Pipeline
	UpdatedBy     *User
}

// NewStruct creates a new relationship struct
func (*deploymentR) NewStruct() *deploymentR {
	return &deploymentR{}
}

// deploymentL is where Load methods for each relationship are stored.
type deploymentL struct{}

var (
	deploymentAllColumns            = []string{"id", "pipeline_id", "configuration_id", "environment_id", "created_at", "created_by_id", "updated_at", "updated_by_id", "replicas", "url", "image", "host", "path", "rewrite_target", "full_name", "dirty"}
	deploymentColumnsWithoutDefault = []string{"pipeline_id", "configuration_id", "environment_id", "created_at", "created_by_id", "updated_at", "updated_by_id", "replicas", "url", "image", "host", "path", "rewrite_target", "full_name", "dirty"}
	deploymentColumnsWithDefault    = []string{"id"}
	deploymentPrimaryKeyColumns     = []string{"id"}
)

type (
	// DeploymentSlice is an alias for a slice of pointers to Deployment.
	// This should generally be used opposed to []Deployment.
	DeploymentSlice []*Deployment
	// DeploymentHook is the signature for custom Deployment hook methods
	DeploymentHook func(context.Context, boil.ContextExecutor, *Deployment) error

	deploymentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	deploymentType                 = reflect.TypeOf(&Deployment{})
	deploymentMapping              = queries.MakeStructMapping(deploymentType)
	deploymentPrimaryKeyMapping, _ = queries.BindMapping(deploymentType, deploymentMapping, deploymentPrimaryKeyColumns)
	deploymentInsertCacheMut       sync.RWMutex
	deploymentInsertCache          = make(map[string]insertCache)
	deploymentUpdateCacheMut       sync.RWMutex
	deploymentUpdateCache          = make(map[string]updateCache)
	deploymentUpsertCacheMut       sync.RWMutex
	deploymentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var deploymentBeforeInsertHooks []DeploymentHook
var deploymentBeforeUpdateHooks []DeploymentHook
var deploymentBeforeDeleteHooks []DeploymentHook
var deploymentBeforeUpsertHooks []DeploymentHook

var deploymentAfterInsertHooks []DeploymentHook
var deploymentAfterSelectHooks []DeploymentHook
var deploymentAfterUpdateHooks []DeploymentHook
var deploymentAfterDeleteHooks []DeploymentHook
var deploymentAfterUpsertHooks []DeploymentHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Deployment) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Deployment) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Deployment) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Deployment) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Deployment) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Deployment) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Deployment) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Deployment) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Deployment) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deploymentAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDeploymentHook registers your hook function for all future operations.
func AddDeploymentHook(hookPoint boil.HookPoint, deploymentHook DeploymentHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		deploymentBeforeInsertHooks = append(deploymentBeforeInsertHooks, deploymentHook)
	case boil.BeforeUpdateHook:
		deploymentBeforeUpdateHooks = append(deploymentBeforeUpdateHooks, deploymentHook)
	case boil.BeforeDeleteHook:
		deploymentBeforeDeleteHooks = append(deploymentBeforeDeleteHooks, deploymentHook)
	case boil.BeforeUpsertHook:
		deploymentBeforeUpsertHooks = append(deploymentBeforeUpsertHooks, deploymentHook)
	case boil.AfterInsertHook:
		deploymentAfterInsertHooks = append(deploymentAfterInsertHooks, deploymentHook)
	case boil.AfterSelectHook:
		deploymentAfterSelectHooks = append(deploymentAfterSelectHooks, deploymentHook)
	case boil.AfterUpdateHook:
		deploymentAfterUpdateHooks = append(deploymentAfterUpdateHooks, deploymentHook)
	case boil.AfterDeleteHook:
		deploymentAfterDeleteHooks = append(deploymentAfterDeleteHooks, deploymentHook)
	case boil.AfterUpsertHook:
		deploymentAfterUpsertHooks = append(deploymentAfterUpsertHooks, deploymentHook)
	}
}

// One returns a single deployment record from the query.
func (q deploymentQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Deployment, error) {
	o := &Deployment{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		return nil, errors.Wrap(err, "orm: failed to execute a one query for deployment")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Deployment records from the query.
func (q deploymentQuery) All(ctx context.Context, exec boil.ContextExecutor) (DeploymentSlice, error) {
	var o []*Deployment

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "orm: failed to assign all query results to Deployment slice")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Deployment records in the query.
func (q deploymentQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to count deployment rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q deploymentQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "orm: failed to check if deployment exists")
	}

	return count > 0, nil
}

// Configuration pointed to by the foreign key.
func (o *Deployment) Configuration(mods ...qm.QueryMod) configurationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ConfigurationID),
	}

	queryMods = append(queryMods, mods...)

	query := Configurations(queryMods...)
	queries.SetFrom(query.Query, "\"configuration\"")

	return query
}

// CreatedBy pointed to by the foreign key.
func (o *Deployment) CreatedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Environment pointed to by the foreign key.
func (o *Deployment) Environment(mods ...qm.QueryMod) environmentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EnvironmentID),
	}

	queryMods = append(queryMods, mods...)

	query := Environments(queryMods...)
	queries.SetFrom(query.Query, "\"environment\"")

	return query
}

// Pipeline pointed to by the foreign key.
func (o *Deployment) Pipeline(mods ...qm.QueryMod) pipelineQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PipelineID),
	}

	queryMods = append(queryMods, mods...)

	query := Pipelines(queryMods...)
	queries.SetFrom(query.Query, "\"pipeline\"")

	return query
}

// UpdatedBy pointed to by the foreign key.
func (o *Deployment) UpdatedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UpdatedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// LoadConfiguration allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deploymentL) LoadConfiguration(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeployment interface{}, mods queries.Applicator) error {
	var slice []*Deployment
	var object *Deployment

	if singular {
		object = maybeDeployment.(*Deployment)
	} else {
		slice = *maybeDeployment.(*[]*Deployment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deploymentR{}
		}
		args = append(args, object.ConfigurationID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deploymentR{}
			}

			for _, a := range args {
				if a == obj.ConfigurationID {
					continue Outer
				}
			}

			args = append(args, obj.ConfigurationID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`configuration`), qm.WhereIn(`configuration.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Configuration")
	}

	var resultSlice []*Configuration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Configuration")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for configuration")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for configuration")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Configuration = foreign
		if foreign.R == nil {
			foreign.R = &configurationR{}
		}
		foreign.R.Deployments = append(foreign.R.Deployments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ConfigurationID == foreign.ID {
				local.R.Configuration = foreign
				if foreign.R == nil {
					foreign.R = &configurationR{}
				}
				foreign.R.Deployments = append(foreign.R.Deployments, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deploymentL) LoadCreatedBy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeployment interface{}, mods queries.Applicator) error {
	var slice []*Deployment
	var object *Deployment

	if singular {
		object = maybeDeployment.(*Deployment)
	} else {
		slice = *maybeDeployment.(*[]*Deployment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deploymentR{}
		}
		args = append(args, object.CreatedByID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deploymentR{}
			}

			for _, a := range args {
				if a == obj.CreatedByID {
					continue Outer
				}
			}

			args = append(args, obj.CreatedByID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`users`), qm.WhereIn(`users.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByDeployments = append(foreign.R.CreatedByDeployments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CreatedByID == foreign.ID {
				local.R.CreatedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByDeployments = append(foreign.R.CreatedByDeployments, local)
				break
			}
		}
	}

	return nil
}

// LoadEnvironment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deploymentL) LoadEnvironment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeployment interface{}, mods queries.Applicator) error {
	var slice []*Deployment
	var object *Deployment

	if singular {
		object = maybeDeployment.(*Deployment)
	} else {
		slice = *maybeDeployment.(*[]*Deployment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deploymentR{}
		}
		args = append(args, object.EnvironmentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deploymentR{}
			}

			for _, a := range args {
				if a == obj.EnvironmentID {
					continue Outer
				}
			}

			args = append(args, obj.EnvironmentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`environment`), qm.WhereIn(`environment.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Environment")
	}

	var resultSlice []*Environment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Environment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for environment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for environment")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Environment = foreign
		if foreign.R == nil {
			foreign.R = &environmentR{}
		}
		foreign.R.Deployments = append(foreign.R.Deployments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.EnvironmentID == foreign.ID {
				local.R.Environment = foreign
				if foreign.R == nil {
					foreign.R = &environmentR{}
				}
				foreign.R.Deployments = append(foreign.R.Deployments, local)
				break
			}
		}
	}

	return nil
}

// LoadPipeline allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deploymentL) LoadPipeline(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeployment interface{}, mods queries.Applicator) error {
	var slice []*Deployment
	var object *Deployment

	if singular {
		object = maybeDeployment.(*Deployment)
	} else {
		slice = *maybeDeployment.(*[]*Deployment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deploymentR{}
		}
		args = append(args, object.PipelineID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deploymentR{}
			}

			for _, a := range args {
				if a == obj.PipelineID {
					continue Outer
				}
			}

			args = append(args, obj.PipelineID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`pipeline`), qm.WhereIn(`pipeline.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Pipeline")
	}

	var resultSlice []*Pipeline
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Pipeline")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for pipeline")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for pipeline")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Pipeline = foreign
		if foreign.R == nil {
			foreign.R = &pipelineR{}
		}
		foreign.R.Deployments = append(foreign.R.Deployments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PipelineID == foreign.ID {
				local.R.Pipeline = foreign
				if foreign.R == nil {
					foreign.R = &pipelineR{}
				}
				foreign.R.Deployments = append(foreign.R.Deployments, local)
				break
			}
		}
	}

	return nil
}

// LoadUpdatedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deploymentL) LoadUpdatedBy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeployment interface{}, mods queries.Applicator) error {
	var slice []*Deployment
	var object *Deployment

	if singular {
		object = maybeDeployment.(*Deployment)
	} else {
		slice = *maybeDeployment.(*[]*Deployment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deploymentR{}
		}
		args = append(args, object.UpdatedByID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deploymentR{}
			}

			for _, a := range args {
				if a == obj.UpdatedByID {
					continue Outer
				}
			}

			args = append(args, obj.UpdatedByID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`users`), qm.WhereIn(`users.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(deploymentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UpdatedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.UpdatedByDeployments = append(foreign.R.UpdatedByDeployments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UpdatedByID == foreign.ID {
				local.R.UpdatedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.UpdatedByDeployments = append(foreign.R.UpdatedByDeployments, local)
				break
			}
		}
	}

	return nil
}

// SetConfiguration of the deployment to the related item.
// Sets o.R.Configuration to related.
// Adds o to related.R.Deployments.
func (o *Deployment) SetConfiguration(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Configuration) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"configuration_id"}),
		strmangle.WhereClause("\"", "\"", 2, deploymentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ConfigurationID = related.ID
	if o.R == nil {
		o.R = &deploymentR{
			Configuration: related,
		}
	} else {
		o.R.Configuration = related
	}

	if related.R == nil {
		related.R = &configurationR{
			Deployments: DeploymentSlice{o},
		}
	} else {
		related.R.Deployments = append(related.R.Deployments, o)
	}

	return nil
}

// SetCreatedBy of the deployment to the related item.
// Sets o.R.CreatedBy to related.
// Adds o to related.R.CreatedByDeployments.
func (o *Deployment) SetCreatedBy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, deploymentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CreatedByID = related.ID
	if o.R == nil {
		o.R = &deploymentR{
			CreatedBy: related,
		}
	} else {
		o.R.CreatedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByDeployments: DeploymentSlice{o},
		}
	} else {
		related.R.CreatedByDeployments = append(related.R.CreatedByDeployments, o)
	}

	return nil
}

// SetEnvironment of the deployment to the related item.
// Sets o.R.Environment to related.
// Adds o to related.R.Deployments.
func (o *Deployment) SetEnvironment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Environment) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"environment_id"}),
		strmangle.WhereClause("\"", "\"", 2, deploymentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.EnvironmentID = related.ID
	if o.R == nil {
		o.R = &deploymentR{
			Environment: related,
		}
	} else {
		o.R.Environment = related
	}

	if related.R == nil {
		related.R = &environmentR{
			Deployments: DeploymentSlice{o},
		}
	} else {
		related.R.Deployments = append(related.R.Deployments, o)
	}

	return nil
}

// SetPipeline of the deployment to the related item.
// Sets o.R.Pipeline to related.
// Adds o to related.R.Deployments.
func (o *Deployment) SetPipeline(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Pipeline) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"pipeline_id"}),
		strmangle.WhereClause("\"", "\"", 2, deploymentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PipelineID = related.ID
	if o.R == nil {
		o.R = &deploymentR{
			Pipeline: related,
		}
	} else {
		o.R.Pipeline = related
	}

	if related.R == nil {
		related.R = &pipelineR{
			Deployments: DeploymentSlice{o},
		}
	} else {
		related.R.Deployments = append(related.R.Deployments, o)
	}

	return nil
}

// SetUpdatedBy of the deployment to the related item.
// Sets o.R.UpdatedBy to related.
// Adds o to related.R.UpdatedByDeployments.
func (o *Deployment) SetUpdatedBy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"updated_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, deploymentPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UpdatedByID = related.ID
	if o.R == nil {
		o.R = &deploymentR{
			UpdatedBy: related,
		}
	} else {
		o.R.UpdatedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			UpdatedByDeployments: DeploymentSlice{o},
		}
	} else {
		related.R.UpdatedByDeployments = append(related.R.UpdatedByDeployments, o)
	}

	return nil
}

// Deployments retrieves all the records using an executor.
func Deployments(mods ...qm.QueryMod) deploymentQuery {
	mods = append(mods, qm.From("\"deployment\""))
	return deploymentQuery{NewQuery(mods...)}
}

// FindDeployment retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDeployment(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Deployment, error) {
	deploymentObj := &Deployment{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"deployment\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, deploymentObj)
	if err != nil {
		return nil, errors.Wrap(err, "orm: unable to select from deployment")
	}

	return deploymentObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Deployment) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("orm: no deployment provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deploymentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	deploymentInsertCacheMut.RLock()
	cache, cached := deploymentInsertCache[key]
	deploymentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			deploymentAllColumns,
			deploymentColumnsWithDefault,
			deploymentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(deploymentType, deploymentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(deploymentType, deploymentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"deployment\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"deployment\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "orm: unable to insert into deployment")
	}

	if !cached {
		deploymentInsertCacheMut.Lock()
		deploymentInsertCache[key] = cache
		deploymentInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Deployment.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Deployment) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	deploymentUpdateCacheMut.RLock()
	cache, cached := deploymentUpdateCache[key]
	deploymentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			deploymentAllColumns,
			deploymentPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("orm: unable to update deployment, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"deployment\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, deploymentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(deploymentType, deploymentMapping, append(wl, deploymentPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to update deployment row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to get rows affected by update for deployment")
	}

	if !cached {
		deploymentUpdateCacheMut.Lock()
		deploymentUpdateCache[key] = cache
		deploymentUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q deploymentQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to update all for deployment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to retrieve rows affected for deployment")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DeploymentSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("orm: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deploymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"deployment\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, deploymentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to update all in deployment slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to retrieve rows affected all in update all deployment")
	}
	return rowsAff, nil
}

// Delete deletes a single Deployment record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Deployment) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("orm: no Deployment provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), deploymentPrimaryKeyMapping)
	sql := "DELETE FROM \"deployment\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to delete from deployment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to get rows affected by delete for deployment")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q deploymentQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("orm: no deploymentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to delete all from deployment")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to get rows affected by deleteall for deployment")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DeploymentSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(deploymentBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deploymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"deployment\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deploymentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "orm: unable to delete all from deployment slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to get rows affected by deleteall for deployment")
	}

	if len(deploymentAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Deployment) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDeployment(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DeploymentSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DeploymentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deploymentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"deployment\".* FROM \"deployment\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deploymentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "orm: unable to reload all in DeploymentSlice")
	}

	*o = slice

	return nil
}

// DeploymentExists checks if the Deployment row exists.
func DeploymentExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"deployment\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "orm: unable to check if deployment exists")
	}

	return exists, nil
}

// Deployment is an object representing the database table.
type DeploymentDTO struct {
	ID              int64     `boil:"id" json:"id" toml:"id" yaml:"id"`
	PipelineID      int64     `boil:"pipeline_id" json:"pipelineID" toml:"pipelineID" yaml:"pipelineID"`
	ConfigurationID int64     `boil:"configuration_id" json:"configurationID" toml:"configurationID" yaml:"configurationID"`
	EnvironmentID   int64     `boil:"environment_id" json:"environmentID" toml:"environmentID" yaml:"environmentID"`
	CreatedAt       time.Time `boil:"created_at" json:"createdAt" toml:"createdAt" yaml:"createdAt"`
	CreatedByID     int64     `boil:"created_by_id" json:"createdByID" toml:"createdByID" yaml:"createdByID"`
	UpdatedAt       time.Time `boil:"updated_at" json:"updatedAt" toml:"updatedAt" yaml:"updatedAt"`
	UpdatedByID     int64     `boil:"updated_by_id" json:"updatedByID" toml:"updatedByID" yaml:"updatedByID"`
	Replicas        int64     `boil:"replicas" json:"replicas" toml:"replicas" yaml:"replicas"`
	URL             string    `boil:"url" json:"url" toml:"url" yaml:"url"`
	Image           string    `boil:"image" json:"image" toml:"image" yaml:"image"`
	Host            string    `boil:"host" json:"host" toml:"host" yaml:"host"`
	Path            string    `boil:"path" json:"path" toml:"path" yaml:"path"`
	RewriteTarget   string    `boil:"rewrite_target" json:"rewriteTarget" toml:"rewriteTarget" yaml:"rewriteTarget"`
	FullName        string    `boil:"full_name" json:"fullName" toml:"fullName" yaml:"fullName"`
	Dirty           bool      `boil:"dirty" json:"dirty" toml:"dirty" yaml:"dirty"`
}

// DTO converts the Deployment to a DeploymentDTO struct.
func (o Deployment) DTO() *DeploymentDTO {
	return &DeploymentDTO{
		ID:              o.ID,
		PipelineID:      o.PipelineID,
		ConfigurationID: o.ConfigurationID,
		EnvironmentID:   o.EnvironmentID,
		CreatedAt:       o.CreatedAt,
		CreatedByID:     o.CreatedByID,
		UpdatedAt:       o.UpdatedAt,
		UpdatedByID:     o.UpdatedByID,
		Replicas:        o.Replicas,
		URL:             o.URL,
		Image:           o.Image,
		Host:            o.Host,
		Path:            o.Path,
		RewriteTarget:   o.RewriteTarget,
		FullName:        o.FullName,
		Dirty:           o.Dirty,
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Deployment) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("orm: no deployment provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deploymentColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	deploymentUpsertCacheMut.RLock()
	cache, cached := deploymentUpsertCache[key]
	deploymentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			deploymentAllColumns,
			deploymentColumnsWithDefault,
			deploymentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			deploymentAllColumns,
			deploymentPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("orm: unable to upsert deployment, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(deploymentPrimaryKeyColumns))
			copy(conflict, deploymentPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"deployment\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(deploymentType, deploymentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(deploymentType, deploymentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "orm: unable to upsert deployment")
	}

	if !cached {
		deploymentUpsertCacheMut.Lock()
		deploymentUpsertCache[key] = cache
		deploymentUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
